import React, { useEffect, useRef, useState } from 'react';
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader';

const ModelTest = () => {
  const mountRef = useRef(null);
  const toolsRef = useRef([]);
  const [physicsObjects, setPhysicsObjects] = useState([]);
  
  useEffect(() => {
    // Scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xA3A3A3);

    // Camera setup
    const camera = new THREE.PerspectiveCamera(
      38,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    camera.position.set(0, 0.5, 1);

    // Renderer setup
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    mountRef.current.appendChild(renderer.domElement);

    // Controls
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;

    // Lights
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(5, 5, 5);
    directionalLight.castShadow = true;
    scene.add(directionalLight);

    // Ground plane
    const groundGeometry = new THREE.PlaneGeometry(2, 2);
    const groundMaterial = new THREE.MeshStandardMaterial({ 
      color: 0x808080,
      roughness: 0.8,
      metalness: 0.2
    });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);

    // Tool names to identify meshes
    const toolNames = [
      'turnscrew2', 'turnscrew', 'wrench', 'knife', 
      'roulette', 'insulatingtape', 'pliers'
    ];

    // Physics properties
    const gravity = -9.81;
    const timeStep = 1/60;

    // Load tools
    const loader = new GLTFLoader();
    loader.load('/tools_pack.glb', (gltf) => {
      const model = gltf.scene;
      model.scale.set(0.1, 0.1, 0.1);
      
      // Process each tool mesh
      model.traverse((child) => {
        if (child.isMesh) {
          toolNames.forEach(toolName => {
            if (child.name.toLowerCase().includes(toolName)) {
              // Clone the mesh to make it independent
              const toolMesh = child.clone();
              toolMesh.castShadow = true;
              toolMesh.receiveShadow = true;
              
              // Random starting position above ground in a very tight group
              toolMesh.position.set(
                Math.random() * 0.1,     // Scaled down x range
                1 + Math.random() * 0.1, // Scaled down y height
                Math.random() * 0.1      // Scaled down z range
              );
              
              // Add random rotation
              toolMesh.rotation.set(
                Math.random() * Math.PI * 2, // Random rotation around X axis
                Math.random() * Math.PI * 2, // Random rotation around Y axis
                Math.random() * Math.PI * 2  // Random rotation around Z axis
              );
              
              // Add physics properties
              toolMesh.userData.velocity = new THREE.Vector3(0, 0, 0);
              toolMesh.userData.acceleration = new THREE.Vector3(0, gravity, 0);
              toolMesh.userData.onGround = false;
              
              scene.add(toolMesh);
              toolsRef.current.push(toolMesh);
            }
          });
        }
      });
    });

    // Animation loop with physics
    function animate() {
      requestAnimationFrame(animate);
      
      // Update physics for each tool
      toolsRef.current.forEach(tool => {
        if (!tool.userData.onGround) {
          // Update velocity
          tool.userData.velocity.y += tool.userData.acceleration.y * timeStep;
          
          // Update position
          tool.position.y += tool.userData.velocity.y * timeStep;
          
          // Ground collision check
          if (tool.position.y <= 0.1) {
            tool.position.y = 0.1;  // Prevent going below ground
            tool.userData.velocity.y = 0;
            tool.userData.onGround = true;
          }
        }
      });

      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    // Handle window resize
    const handleResize = () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    };
    window.addEventListener('resize', handleResize);

    // Cleanup
    return () => {
      window.removeEventListener('resize', handleResize);
      toolsRef.current = [];
      if (mountRef.current && renderer.domElement) {
        mountRef.current.removeChild(renderer.domElement);
      }
      renderer.dispose();
    };
  }, []);

  return <div ref={mountRef} />;
};

export default ModelTest;